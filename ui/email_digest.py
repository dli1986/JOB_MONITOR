import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime, timedelta
from typing import List
from collector.db import db_manager, JobEntry
from config.config_loader import config_loader

class EmailDigest:
    def __init__(self):
        self.smtp_host = config_loader.get_env('SMTP_HOST')
        self.smtp_port = int(config_loader.get_env('SMTP_PORT', 587))
        self.smtp_username = config_loader.get_env('SMTP_USERNAME')
        self.smtp_password = config_loader.get_env('SMTP_PASSWORD')
        self.recipients = config_loader.get_env('EMAIL_RECIPIENTS', '').split(',')
        self.recipients = [r.strip() for r in self.recipients if r.strip()]
    
    def send_daily_digest(self):
        """Send daily digest email with new job postings"""
        if not self._is_configured():
            print("Email not configured, skipping digest")
            return
        
        # Get jobs from the last 24 hours
        yesterday = datetime.now() - timedelta(days=1)
        recent_jobs = self._get_recent_jobs(yesterday)
        
        if not recent_jobs:
            print("No new jobs to send in digest")
            return
        
        # Generate email content
        subject = f"Daily Job Digest - {len(recent_jobs)} New Positions"
        html_content = self._generate_html_digest(recent_jobs)
        text_content = self._generate_text_digest(recent_jobs)
        
        # Send email
        try:
            self._send_email(subject, html_content, text_content)
            #self._send_email_sendgrid(subject, html_content, text_content)
            print(f"Daily digest sent to {len(self.recipients)} recipients")
        except Exception as e:
            print(f"Error sending digest email: {e}")
    
    def _is_configured(self) -> bool:
        """Check if email is properly configured"""
        required = [self.smtp_host, self.smtp_username, self.smtp_password]
        return all(required) and len(self.recipients) > 0
    
    def _get_recent_jobs(self, since_date: datetime) -> List[JobEntry]:
        """Get jobs added since the specified date"""
        return db_manager.session.query(JobEntry).filter(
            JobEntry.created_at >= since_date
        ).order_by(JobEntry.created_at.desc()).all()
    
    def _generate_html_digest(self, jobs: List[JobEntry]) -> str:
        """Generate HTML email content"""
        html = f"""
        <html>
        <head>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .job-entry {{ border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }}
                .job-title {{ font-size: 18px; font-weight: bold; color: #2c3e50; }}
                .job-source {{ color: #7f8c8d; font-style: italic; }}
                .job-link {{ color: #3498db; text-decoration: none; }}
                .job-analysis {{ margin-top: 10px; padding: 10px; background-color: #f8f9fa; border-left: 3px solid #28a745; }}
                .summary {{ margin-top: 10px; }}
            </style>
        </head>
        <body>
            <h1>ðŸŽ¯ Daily Job Monitor Digest</h1>
            <p>Found <strong>{len(jobs)}</strong> new job postings in the last 24 hours:</p>
        """
        
        for job in jobs:
            html += f"""
            <div class="job-entry">
                <div class="job-title">{job.title}</div>
                <div class="job-source">Source: {job.source} | Published: {job.published}</div>
                <div class="job-link">
                    <a href="{job.link}" target="_blank">ðŸ”— View Full Posting</a>
                </div>
            """
            
            if job.analysis_result:
                html += f"""
                <div class="job-analysis">
                    <div style="white-space: pre-line;">{job.analysis_result}</div>
                </div>
                """
            else:
                description = job.description[:300] + "..." if len(job.description) > 300 else job.description
                html += f"""
                <div class="summary">
                    <p>{description}</p>
                </div>
                """
            
            html += "</div>"
        
        html += """
            <hr>
            <p style="color: #7f8c8d; font-size: 12px;">
                This digest was automatically generated by the Job Monitor system.
            </p>
        </body>
        </html>
        """
        
        return html
    
    def _generate_text_digest(self, jobs: List[JobEntry]) -> str:
        """Generate plain text email content"""
        text = f"Daily Job Monitor Digest\n"
        text += f"========================\n\n"
        text += f"Found {len(jobs)} new job postings in the last 24 hours:\n\n"
        
        for i, job in enumerate(jobs, 1):
            text += f"{i}. {job.title}\n"
            text += f"   Source: {job.source}\n"
            text += f"   Published: {job.published}\n"
            text += f"   Link: {job.link}\n"
            
            if job.analysis_result:
                # Extract summary from analysis for text version
                summary_start = job.analysis_result.find("## Summary")
                if summary_start != -1:
                    summary_text = job.analysis_result[summary_start:].split('\n')[1:3]
                    text += f"   Summary: {' '.join(summary_text)}\n"
            
            text += "\n" + "-" * 50 + "\n\n"
        
        text += "This digest was automatically generated by the Job Monitor system.\n"
        return text
    
    def _send_email(self, subject: str, html_content: str, text_content: str):
        """Send email via configured method"""
        email_method = config_loader.get_env('EMAIL_METHOD', 'gmail_api')  # smtp or gmail_api
        
        if email_method == 'gmail_api':
            self._send_email_gmail_api(subject, html_content, text_content)
        else:
            # Existing SMTP code
            self._send_email_smtp(subject, html_content, text_content)
            
    def _send_email_smtp(self, subject: str, html_content: str, text_content: str):
        """Send email via SMTP"""
        # Create message
        msg = MIMEMultipart('alternative')
        msg['Subject'] = subject
        msg['From'] = self.smtp_username
        msg['To'] = ', '.join(self.recipients)
        
        # Attach text and HTML versions
        text_part = MIMEText(text_content, 'plain', 'utf-8')
        html_part = MIMEText(html_content, 'html', 'utf-8')
        
        msg.attach(text_part)
        msg.attach(html_part)
        
        # Send email
        with smtplib.SMTP(self.smtp_host, self.smtp_port) as server:
            server.starttls()
            server.login(self.smtp_username, self.smtp_password)
            server.send_message(msg)
    
    def _send_email_sendgrid(self, subject: str, html_content: str, text_content: str):
        """Send email via SendGrid API"""
        import requests
        
        api_key = config_loader.get_env('SENDGRID_API_KEY')
        print(f"Using SendGrid API Key: {api_key}")
        url = "https://api.sendgrid.com/v3/mail/send"
        
        data = {
            "personalizations": [{"to": [{"email": r} for r in self.recipients]}],
            "from": {"email": self.smtp_username},
            "subject": subject,
            "content": [
                {"type": "text/plain", "value": text_content},
                {"type": "text/html", "value": html_content}
            ]
        }
        
        headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
        response = requests.post(url, headers=headers, json=data)
        response.raise_for_status()
    
    def send_manual_digest(self, hours_back: int = 24):
        """Send digest for jobs from specified hours back"""
        if not self._is_configured():
            print("Email not configured")
            return False
        
        from datetime import datetime, timedelta
        since_date = datetime.now() - timedelta(hours=hours_back)
        recent_jobs = self._get_recent_jobs(since_date)
        
        if not recent_jobs:
            print(f"No jobs found in last {hours_back} hours")
            return False
        
        subject = f"Manual Job Digest - {len(recent_jobs)} Positions (Last {hours_back}h)"
        html_content = self._generate_html_digest(recent_jobs)
        text_content = self._generate_text_digest(recent_jobs)
        
        try:
            self._send_email(subject, html_content, text_content)
            print(f"Manual digest sent with {len(recent_jobs)} jobs")
            return True
        except Exception as e:
            print(f"Error sending manual digest: {e}")
            return False
    
    def _send_email_gmail_api(self, subject: str, html_content: str, text_content: str):
        """Send email via Gmail API"""
        try:
            from google.auth.transport.requests import Request
            from google.oauth2.credentials import Credentials
            from googleapiclient.discovery import build
            import base64
            from email.mime.multipart import MIMEMultipart
            from email.mime.text import MIMEText
            
            # Load credentials from file or env
            # token.json is gmail_credentials.json
            creds_path = config_loader.get_env('GMAIL_CREDENTIALS_PATH', 'token.json')
            creds = Credentials.from_authorized_user_file(creds_path)
            
            service = build('gmail', 'v1', credentials=creds)
            
            # Create message
            message = MIMEMultipart('alternative')
            message['to'] = ', '.join(self.recipients)
            message['subject'] = subject
            
            message.attach(MIMEText(text_content, 'plain'))
            message.attach(MIMEText(html_content, 'html'))
            
            # Encode message
            raw_message = base64.urlsafe_b64encode(message.as_bytes()).decode()
            
            # Send
            service.users().messages().send(
                userId='me',
                body={'raw': raw_message}
            ).execute()
            
        except Exception as e:
            print(f"Gmail API error: {e}")
            raise

# Global instance for scheduler
email_digest = EmailDigest()

def send_daily_digest():
    """Function called by scheduler"""
    email_digest.send_daily_digest()